![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/3ec3281d-887f-48ce-8415-ac50e8690dcb.png)

本文只是弹幕的基础发射，不涉及射击游戏的相关内容，相对简单。

在本文中将了解：

1. 动态加载Scene
2. 计时器 Timer
3. 旋转 Rotation
4. 离开屏幕销毁对象（Scene)

## 弹幕的构成

所谓弹幕，其实就是大量的子弹按一定的方向和速度运动而成。因以，制作弹幕可以拆解成两个场景：

1. 子弹
2. 武器

### 子弹

子弹的属性包括：

- 大小
- 速度
- 方向（旋转的角度）

### 武器

武器其实就是子弹的控制器，它做的事情：

- 创建一定的数量的子弹
- 控制子弹方向
- 控制子弹发射

例如：

- 武器1，使用子弹1，同时向四周按相同的角度间隔（22.5度）发射18颗子弹
- 武器2，使用子弹1，按顺时针方向旋转，每隔0.1秒发射一颗子弹

当设置好所有子弹和武器后，就可以根据角色来使用各种武器，那么接着，我们就来创建它们。

## 创建子弹

在这里，我们不使用Sprite，只使用多边形来作为子弹，因此就不需要任何素材了。

### Step 1 创建场景和根节点

新建Scene，使用 **KinematicBody2D** 作为根节点，命名为 **Bullet01**。 

之所以使用 **KinematicBody2D** ，是因为它既可以受力作用，也可以进行碰撞检测，却又不会受到物理引擎的主动控制。非常适合用于子弹。

### Step 2 创建形状

为**Bullet01** 节点添加子节点 **Polygon2D** ，并创建形状：

打开 **Inspector** >  **Data** >  **Polygon** ， 将**Size**设置为4。同时为下面出现的点添加x, y值。考虑到演示作用，我们将子弹做大一点，因此，将边长设置为10，如：0.x = 10, 0.y = -10, 1.x = 10, 1.y = -10, 2.x = 10, 2.y = 10, 3.x = -10, 3.y = 10。

![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/ea83823c-f627-4b88-a42d-01043be7b7d0.png)

同时，可以看到视图窗口中出现了一个正方形。

![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/94c5ee88-07fa-4322-ba75-23fb16257be0.png)

### Step 3 添加碰撞体

为 **Bullet01** 添加子节点 **CollisionShape2D** 节点。

其实只是演示弹幕，并不需要添加此节点，但为了消除KinematicBody2D节点上的感叹号，就创建一个吧（洁癖）。

选中CollisionShape2D节点，打开 **Inspector** >  **Shape** 对话框，选择 **New RectangleShape2D**。

![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/bc9a3196-2ab4-4573-85e4-ab00c511acea.png) 

同时在视图窗口中，将CollisionShape2D的图形拉到完全覆盖正方形。

![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/ed92e3c3-a831-4064-98e5-e935c4ad0264.png)

### Step 4 添加可见控制节点

再为 **Bullet01** 节点添加子节点 **VisibilityNotifier2D** 节点。

它的作用只有一个，用来检测对象是否已离开屏幕，如果是销毁它。当然，这需要在脚本里控制，现在将它添加进来就可以了。

### Step 5 添加脚本

选中 **Bullet01** 节点，为其创建一个脚本 **Bullet01.gd**，打开脚本。

首先定义两个变量：

```
var speed = 750
var velocity = Vector2()
```

接着创建start函数。以便武器调用。

```
func start(pos, dir):
	position = pos
	rotation = dir
	velocity = Vector2(speed, 0).rotated(rotation)
```

start函数有两个参数：

- pos: 武器传入的位置信息，是Vector2对象
- dir：武器传入的旋转角度

 **position** 是当前节点所在的位置，将武器的指定的位置传递给它后，那么子弹自然就出现在其位置。

 **rotation** 是当前节点的旋转角色，它是以横坐标为0度开始，顺时间旋转。

 **velocity** 即给对象一个在x轴上的向量。因为节点是KinematicBody2D，因此，在力的作用下，它就会开始以speed值的速度开始移动。当然，这需要在 **_physics_process** 函数中执行移动方法。那么，接着就来创建它。

```
func _physics_process(delta):
	move_and_collide(velocity * delta)
```

但，如果只是这样，当子弹被初始化的到场景中时，它就会开始移动了，但有时我们并不想它立即移动，因此需要去它做一个控制。当然控制它的就是实例化它的武器。调整一下此函数：

```
func _physics_process(delta):
	if get_parent().isShooting:
		move_and_collide(velocity * delta)
```

 **get_parent()** : 父节点，也就是我们的武器。它有个变量 **running** ，默认可以是true或false，根本武器的实际情况给予初始值。后面我们会介绍到两种情况。

### Step 6 处理离开屏幕信号

当子弹离开屏幕后，我们需要将它销毁，这就要用到 **VisibilityNotifier2D** 节点的信号。

选中 **VisibilityNotifier2D** 节点，选择 **Node** 面板，双击 **screen_exited** 信号，在 **Bullet01** 脚本中创建一个函数：

```
func _on_VisibilityNotifier2D_screen_exited():
	queue_free()
```

此函数将在对象离开屏幕后被调用，queue_free()将会销毁此对象。

这样，我们的子弹就算是做好了。接着我们来制作1号武器。

## 创建1号武器

### Step 1 创建场景和根节点

创建一个新场景，直接使用Node2D做为根节点，命名为 **Weapon01**。 

### Step 2 创建脚本

选中 **Weapon01** 节点，为其添加脚本 **Weapon01.gd**。 然后我们从变量开始。


```
var Bullet01 = preload('res://Bullet01.tscn')
var bulletNum = 18
var shootNum = 0
var isShooting = true
```

 **Bullet01** ：我们预加载了Bullet01 Scene，即1号子弹。如果此武器还用到了其它子弹，都可以先加载进来。毕竟一把武器的子弹基本上是固定的。

 **bulletNum** ：发射子弹的数量。这是武器设计的一个参数。可以理解为一梭子弹的数量。我们这的1号武器定义为360度扫射，经过计算一圈18发子弹，每颗子弹间隔22.5度正好。

 **shotNum** ：当前发射子弹数。用于控制什么时候停止发射。

 **isShooting** ：是否开始射击。 **Weapon01** 是加载就直接开始射击，所以这里默认为true。

接着创建一个shoot函数，用于实例化子弹并将它添加到武器的场景里。

```
func shoot():
	var b = Bullet01.instance()
	b.start(Vector2(0, 0), shootNum * 0.35)
	add_child(b)
	shootNum += 1
```

在该函数中，实例化子弹后，调用了它的start()函数。用于将子弹的初始位置和旋转角度传递给子弹实例。

position是相对的，当我们把子弹实例添加到武器的场景中时，我们当然希望子弹出现在武器的位置（当然实际情况可能不止于此），所以，子弹相对于武器的位置就是Vector(0, 0)。如果我们将子弹实例添加到主场景里，那子弹的位置就需要用到武器所在位置，即 **position** ，`b.start(position, shootNum * 0.35)`。

前面说了，我们的1号武器是360扫射，每隔一小段时间就发射一颗子弹，因此这里需要使用到计时器。

### Step 3 创建计时器

选中 **Weapon01** 节点，添加子节点 **Timer**。

设置 **Inspector** >  **Wait Time** 为0.1。

打开 **Node** 面板，双击 **timeout()** 信号，添加连接函数到脚本里。

```
func _on_Timer_timeout():
	if shootNum > bulletNum:
		$Timer.stop()
	else:
		shoot()
```

在 **shoot** 函数中， **shootNum** 在每实例化一颗子弹是后，就+1，所以，当shootNum > bulletNum时，停止计时器，不然就调用shoot()函数继续发射子弹。

最后，添加一个start函数，用于调用武器。

```
func start():
	$Timer.start()
```

 **$Timer** 直接获取子节点实例，也就是节点Timer，然后调用它的start()函数。该函数被调用时，会立即触发一次timeout，所以，第一颗子弹会立刻发射出去。

## 创建主场景

有了子弹，有了武器，我们再创建一个主场景，将武器添加到场景里。

### 创建场景和根节点

新建一个场景，添加根节点 **Node2D** ，命名为 **MainScene**。 

接着将 **Weapon01** 拖入场景中的合适位置。

### 创建脚本

选中 **MainScene** 节点，添加脚本 **MainScene.gd** 。

添加_ready函数。

```
func _ready():
	$Weapon01.start()
```

保存后，点击运行，如果没有设置默认场景，将MainScene设置为默认场景，看看效果。

![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/640119ac-a65c-4683-b54a-3de293df3525.gif)

OK，非常简单，我们再试着添加一把武器。 **Weapon02** 同一时间向四周发18颗子弹。

## 创建2号武器

子弹我们还是用1号子弹。

复制 **Weapon01** ，重命名为Weapon02，同时将Weapon02节点上的脚本取消，重新添加一个脚本 **Weapon02**。变量和Weapon01相同。区别在于isShooting = false，因为我们不希望实例化子弹的时候就发射出去了，而是等18颗子弹都实例化好后，再一次性发射。

添加_ready函数，我们将在这里实例化子弹。

```
func _ready():
	for index in bulletNum:
		var b = Bullet01.instance()
		b.start(Vector(0, 0), index * 0.35)
		add_child(b)
```

 添加start函数，用于调用武器。

```
func start():
	isShooting = true
	$Timer.start()
```

这样其实就已经完成了2号武器。这里，我们希望在1号武器发射结束后，再发射2号武器，那么我们可以在1号武器的代码里，添加2号武器的调用。

```
func _on_Timer_timeout():
	if shootNum > bulletNum:
		$Timer.stop()
		get_parent().find_node('Weapon02').start()
	else:
		shoot()
```

保存后，再次点击运行

![](https://raw.githubusercontent.com/yuiitsu/image_lib/master/4231507d-a6e0-4e8f-9314-c64cb85a6ba6.gif)

## 结论

本文内容极其简单，但非常实用，增加一些子弹和武器类型就可以应用到射击游戏上。当然，游戏总不会这么简单。接下来就需要尝试不同的内容了。